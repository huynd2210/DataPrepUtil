import pprint
import textwrap
from typing import Optional

import pandas as pd

from core.distillation import distillKnowledge


def prettyPrintCSV(path: str, chosenColumns: Optional[list[str]] = None):
    df = pd.read_csv(path, on_bad_lines='warn')
    if chosenColumns is not None:
        df = df[chosenColumns]
    textWrapWidth = 160
    batch_size = 100  # Number of rows to display at a time

    # Iterate in batches
    for start_idx in range(0, len(df), batch_size):
        end_idx = start_idx + batch_size
        batch = df.iloc[start_idx:end_idx]

        for index, row in batch.iterrows():
            if row["isVerified"] == 0:

                print(f" Question: {row['question']}" , end="\n\n")
                print(textwrap.fill("gold_solution: " + row["gold_solution"], textWrapWidth), end="\n\n")
                print(textwrap.fill("reasoning: " + row["reasoning"], textWrapWidth), end="\n\n")
                if type(row["verification_solution"]) == float:
                    print("0" * 20)
                    print(row["verification_solution"])
                print(textwrap.fill("verification_solution: " + str(row["verification_solution"]), textWrapWidth), end="\n\n")
                print(textwrap.fill("isVerified: " + str(row["isVerified"]), textWrapWidth), end="\n\n")
                print(textwrap.fill("schema: " + row["schema"], textWrapWidth), end="\n\n")
                print("-" * 20)
                print("\n")

        # Pause before displaying the next batch
        if end_idx < len(df):  # Avoid asking for input after the last batch
            input("Press Enter to view the next set of rows...")
    # pprint.pprint(df)


def analyseEvaluation(evaluationResultDf: pd.DataFrame):
    counter = 0
    for index, row in evaluationResultDf.iterrows():
        if row["isCorrect"]:
            counter += 1

    print("Accuracy: " + str(counter / len(evaluationResultDf)))

def distillWrapper(model_name: str, student_model_name: str, dataset="spider", split="train", batchRange: Optional[tuple[int, int]] = None):
    data = distillKnowledge(model_name, student_model_name, dataset=dataset, split=split, batchRange=batchRange)
    outputName = f"{model_name.replace(':', '-')}_distilled_data_{dataset}_{split}_{batchRange[0]}_{batchRange[1]}.csv"
    print(f"Output saved to {outputName}")
    data.to_csv(outputName)

if __name__ == '__main__':
    # prettyPrintCSV(
    #     "gpt-4o-mini_distilled_data_spider_train_401_1000.csv",
    #     ["question", "gold_solution", "reasoning", "verification_solution", "isVerified", "schema"]
    # )

    model_name = "gpt-4o-mini"
    student_model_name = "qwen2.5-coder:14b-instruct-q4_K_M"
    split = "train"
    batchRange = (1001, 2000)
    datasetName = "spider"
    distillWrapper(model_name, student_model_name, datasetName, split, batchRange)

    # model_name = "llama3.1:8b-instruct-q4_0"



    # result = evaluateModel(model_name, datasetName)
    # analyseEvaluation(result)
    # print("----RESULT----")
    # print(result)
    # outputName = f"{model_name.replace(':', '-')}_{datasetName}_result.csv"
    # print(f"Output saved to {outputName}")
    # result.to_csv(outputName)

    # data = distillKnowledge(model_name, dataset=datasetName, batchRange=batchRange)
    # outputName = f"{model_name.replace(':', '-')}_distilled_data_{datasetName}_{split}_{batchRange[0]}_{batchRange[1]}.csv"
    # print(f"Output saved to {outputName}")
    # data.to_csv(outputName)

    # df = pd.read_csv("qwen2.5-coder-14b-instruct-q4_K_M_distilled_data.csv")
    # print(df["reasoning"].iloc[0])

    # generatedSQL = """
    # SELECT COUNT(*)
    # FROM head AS h
    # WHERE h.age > 56;
    # """
    # gold = """SELECT COUNT(*) FROM head WHERE age > 56;"""
    # path = "spider_data/database/department_management/department_management.sqlite"
    # sample = SQLEvaluationEntry(path, generatedSQL, gold, "question")
    # evaluateSQLGenerationEntry(sample)
